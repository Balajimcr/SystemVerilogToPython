#!/usr/bin/env python3
"""
Auto-generated pyvsc translation from SystemVerilog

IMPORTANT: This is a SUGGESTED translation that requires manual review.
Please verify:
1. All constraint semantics are preserved
2. Data type mappings are correct
3. Distribution weights match original intent
4. Solve order effects are equivalent

Generated by: SV-to-pyvsc Translation Assistant
"""

import vsc
from enum import IntEnum
import random
from typing import Optional

class YuvFormat(IntEnum):
  """Translated from SV enum: yuv_format_e"""
  YUV_444 = 0
  YUV_422 = 1
  YUV_420 = 2

class CompType(IntEnum):
  """Translated from SV enum: comp_type_e"""
  COMP_RGB = 0
  COMP_YUV = 1
  COMP_RAW = 2

class BitDepth(IntEnum):
  """Translated from SV enum: bit_depth_e"""
  BIT_8 = 0
  BIT_10 = 1
  BIT_12 = 3

@vsc.randobj
class IspRandItem:
  """Translated from SV class: isp_rand_item"""

  def __init__(self):
    self.isp_bypass_mode = vsc.rand_bit_t(1)
    self.isp_yuv_format = vsc.rand_enum_t(YuvFormat)
    self.isp_src_comp = vsc.rand_enum_t(CompType)
    self.isp_dst_comp = vsc.rand_enum_t(CompType)
    self.isp_in_bit_depth = vsc.rand_enum_t(BitDepth)
    self.isp_out_bit_depth = vsc.rand_enum_t(BitDepth)
    self.rdma_data_format = vsc.rand_uint32_t()
    self.wdma_data_format = vsc.rand_uint32_t()
    self.isp_grid_2d_0_0 = vsc.rand_int32_t()
    self.isp_grid_2d_0_1 = vsc.rand_int32_t()
    self.isp_grid_2d_0_2 = vsc.rand_int32_t()
    self.isp_grid_2d_0_3 = vsc.rand_int32_t()
    self.isp_grid_2d_0_4 = vsc.rand_int32_t()
    self.isp_grid_2d_0_6 = vsc.rand_int32_t()

  @vsc.constraint
  def solve_order_c(self):
    vsc.solve_order(self.isp_bypass_mode, self.isp_yuv_format)
    vsc.solve_order(self.isp_yuv_format, self.isp_src_comp)
    vsc.solve_order(self.isp_src_comp, self.isp_dst_comp)
    vsc.solve_order(self.isp_dst_comp, self.isp_in_bit_depth)
    vsc.solve_order(self.isp_in_bit_depth, self.isp_out_bit_depth)

  @vsc.constraint
  def enum_ranges_c(self):
    self.isp_bypass_mode in vsc.rangelist(0, 1)
    self.isp_yuv_format in vsc.rangelist(YuvFormat.YUV_444, YuvFormat.YUV_422, YuvFormat.YUV_420)
    self.isp_src_comp in vsc.rangelist(CompType.COMP_RGB, CompType.COMP_YUV, CompType.COMP_RAW)
    self.isp_dst_comp in vsc.rangelist(CompType.COMP_RGB, CompType.COMP_YUV, CompType.COMP_RAW)
    self.isp_in_bit_depth in vsc.rangelist(BitDepth.BIT_8, BitDepth.BIT_10, BitDepth.BIT_12)
    self.isp_out_bit_depth in vsc.rangelist(BitDepth.BIT_8, BitDepth.BIT_10, BitDepth.BIT_12)

  @vsc.constraint
  def dma_format_range_c(self):
    self.rdma_data_format in vsc.rangelist(4, 5, 7, 8, 16, 17, 20, 21, 32, 33)
    self.wdma_data_format in vsc.rangelist(vsc.rng(0, 63))

  @vsc.constraint
  def rdma_format_c(self):
    with vsc.if_then(self.rdma_data_format.inside(vsc.rangelist(4, 5, 16, 17, 20, 21))):
      self.isp_yuv_format == YuvFormat.YUV_444
    with vsc.else_then:
      self.isp_yuv_format in vsc.rangelist(YuvFormat.YUV_422, YuvFormat.YUV_420)

  @vsc.constraint
  def bypass_mode_c(self):
    with vsc.if_then((self.isp_bypass_mode != 0)):
      self.isp_src_comp in vsc.rangelist(CompType.COMP_RGB, CompType.COMP_YUV)
      self.isp_dst_comp == self.isp_src_comp

  @vsc.constraint
  def input_bit_depth_c(self):
    with vsc.if_then(self.rdma_data_format.inside(vsc.rangelist(4, 5, 7, 8))):
      self.isp_in_bit_depth == BitDepth.BIT_8
    with vsc.else_if(self.rdma_data_format.inside(vsc.rangelist(16, 17, 32, 33))):
      self.isp_in_bit_depth == BitDepth.BIT_10
    with vsc.else_then:
      self.isp_in_bit_depth == BitDepth.BIT_12

  @vsc.constraint
  def output_bit_depth_c(self):
    with vsc.if_then(self.isp_in_bit_depth == BitDepth.BIT_8):
      self.isp_out_bit_depth == BitDepth.BIT_8
    with vsc.else_if(self.isp_dst_comp != CompType.COMP_RGB):
      self.isp_out_bit_depth == BitDepth.BIT_10
    with vsc.else_then:
      self.isp_out_bit_depth in vsc.rangelist(BitDepth.BIT_10, BitDepth.BIT_12)

  @vsc.constraint
  def grid_range_c(self):
    self.isp_grid_2d_0_0 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.isp_grid_2d_0_1 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.isp_grid_2d_0_2 in vsc.rangelist(vsc.rng(-512, 511))
    self.isp_grid_2d_0_3 in vsc.rangelist(vsc.rng(-512, 511))
    self.isp_grid_2d_0_4 in vsc.rangelist(-100, -50, 0, 50, 100)
    self.isp_grid_2d_0_6 in vsc.rangelist(vsc.rng(-2048, 2047))

# =============================================================================
# USAGE EXAMPLE
# =============================================================================

if __name__ == '__main__':
  # Set seed for reproducibility (optional)
  # vsc.set_randstate(12345)

  # Create and randomize IspRandItem
  isp_rand_item = IspRandItem()
  isp_rand_item_randomized = False
  try:
    isp_rand_item.randomize()
    isp_rand_item_randomized = True
    print(f'IspRandItem randomized successfully')
  except Exception as e:
    print(f'IspRandItem randomize failed: {e}')

  if isp_rand_item_randomized:
    # Print field values
    print(f'  isp_bypass_mode = {isp_rand_item.isp_bypass_mode}')
    print(f'  isp_yuv_format = {isp_rand_item.isp_yuv_format}')
    print(f'  isp_src_comp = {isp_rand_item.isp_src_comp}')
    print(f'  isp_dst_comp = {isp_rand_item.isp_dst_comp}')
    print(f'  isp_in_bit_depth = {isp_rand_item.isp_in_bit_depth}')
