#!/usr/bin/env python3
"""
Auto-generated pyvsc translation from SystemVerilog

IMPORTANT: This is a SUGGESTED translation that requires manual review.
Please verify:
1. All constraint semantics are preserved
2. Data type mappings are correct
3. Distribution weights match original intent
4. Solve order effects are equivalent

Generated by: SV-to-pyvsc Translation Assistant
"""

import vsc
from enum import IntEnum
import random
from typing import Optional

# =============================================================================
# BASE CLASS STUBS (from UVM or other libraries)
# Replace these with actual implementations or imports as needed
# =============================================================================

@vsc.randobj
class UvmSequenceItem:
    """
    Stub for uvm_sequence_item base class.
    Replace with actual implementation or import from your UVM library.
    """
    def __init__(self):
        pass  # TODO: Add base class fields if needed


@vsc.randobj
class IspRandItemSmall(UvmSequenceItem):
    """Translated from SV class: Isp_rand_item_small"""

    def __init__(self):
        super().__init__()
        self.TestRandInt = vsc.rand_int32_t()
        self.TestRandNibble = vsc.rand_bit_t(4)
        self.TestEnum = vsc.rand_enum_t(TestEnum)
        self.TestFixedArr = vsc.rand_list_t(vsc.bit_t(8), sz=4)
        self.TestDynArr = vsc.rand_list_t(vsc.bit_t(16))
        self.IsIspBypassMode = vsc.rand_bit_t(32)
        self.IsIspYuvFormat = vsc.rand_bit_t(32)
        self.IsIspSrcCompType = vsc.rand_bit_t(32)
        self.IsIspDstCompType = vsc.rand_bit_t(32)
        self.IsIspInBittageType = vsc.rand_bit_t(32)
        self.IsIspOutBittageType = vsc.rand_bit_t(32)
        self.IsRdmaDataFormatYuv = vsc.rand_bit_t(32)
        self.IsWdmaDataFormatYuv = vsc.rand_bit_t(32)
        self.isp_grid_2d_0_0 = vsc.rand_int32_t()
        self.isp_grid_2d_0_1 = vsc.rand_int32_t()
        self.isp_grid_2d_0_2 = vsc.rand_int32_t()
        self.isp_grid_2d_0_3 = vsc.rand_int32_t()
        self.isp_grid_2d_0_4 = vsc.rand_int32_t()
        self.isp_grid_2d_0_6 = vsc.rand_int32_t()

    @vsc.constraint
    def CR_TEST_RAND_INT_RANGE(self):
        self.TestRandInt in vsc.rangelist(vsc.rng(10, 20))

    @vsc.constraint
    def CR_TEST_INSIDE_FORMS(self):
        self.TestRandInt.inside(vsc.rangelist(vsc.rng(5, 15)))
        self.TestRandNibble.inside(vsc.rangelist(0x0, 0xF, 0xA))

    @vsc.constraint
    def CR_TEST_IMPLICATION(self):
        vsc.implies((self.TestRandNibble == 0xF), (self.TestRandInt == 42))

    @vsc.constraint
    def CR_TEST_FOREACH(self):
        with vsc.foreach(self.TestFixedArr, idx=True) as i:
            self.TestFixedArr[i] >= i
            self.TestFixedArr[i] <= 0xFF

    @vsc.constraint
    def CR_TEST_UNIQUE(self):
        vsc.unique(self.TestFixedArr)

    @vsc.constraint
    def CR_TEST_DYN_ARRAY(self):
        self.TestDynArr.size.inside(vsc.rangelist(vsc.rng(1, 8)))

    @vsc.constraint
    def CR_TEST_SOFT(self):
        vsc.soft(self.TestRandInt == 12)

    @vsc.constraint
    def CR_TEST_DIST(self):
        vsc.dist(self.TestRandInt, [
            vsc.weight(10, 10),
            vsc.weight(15, 30),
            vsc.weight(20, 60),
        ])

    @vsc.constraint
    def CR_TEST_MULTI_SOLVE_FANIN(self):
        vsc.solve_order(self.TestEnum, self.TestRandInt)
        vsc.solve_order(self.TestRandNibble, self.TestRandInt)
        with vsc.if_then(self.TestEnum == self.TEST_ENUM_1):
            self.TestRandInt == 15

    @vsc.constraint
    def CR_TEST_MULTI_SOLVE_FANOUT(self):
        vsc.solve_order(self.TestRandInt, self.TestRandNibble)
        vsc.solve_order(self.TestRandInt, self.TestEnum)
        with vsc.if_then(self.TestRandInt == 20):
            self.TestRandNibble == 0xA
        self.TestEnum == self.TEST_ENUM_2

    @vsc.constraint
    def CR_VAR_RANGE_IsIspBypassMode(self):
        self.IsIspBypassMode in vsc.rangelist(vsc.rng(0, 1))

    @vsc.constraint
    def CR_VAR_RANGE_IsIspYuvFormat(self):
        self.IsIspYuvFormat in vsc.rangelist(vsc.rng(0, 1))

    @vsc.constraint
    def CR_VAR_RANGE_IsIspSrcCompType(self):
        self.IsIspSrcCompType in vsc.rangelist(vsc.rng(0, 2))

    @vsc.constraint
    def CR_VAR_RANGE_IsIspDstCompType(self):
        self.IsIspDstCompType in vsc.rangelist(vsc.rng(0, 2))

    @vsc.constraint
    def CR_VAR_RANGE_IsIspInBittageType(self):
        self.IsIspInBittageType in vsc.rangelist(vsc.rng(0, 3))

    @vsc.constraint
    def CR_VAR_RANGE_IsIspOutBittageType(self):
        self.IsIspOutBittageType in vsc.rangelist(vsc.rng(0, 3))

    @vsc.constraint
    def cr1(self):
        vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsIspYuvFormat)
        with vsc.if_then(self.IsRdmaDataFormatYuv.inside(vsc.rangelist(4, 5, 16, 17, 20, 21))):
            self.IsIspYuvFormat == 0
        with vsc.else_then:
            self.IsIspYuvFormat == 1

    @vsc.constraint
    def cr4(self):
        vsc.solve_order(self.IsIspBypassMode, self.IsIspSrcCompType)
        with vsc.if_then((self.IsIspBypassMode != 0)):
            self.IsIspSrcCompType.inside(vsc.rangelist(0, 1))

    @vsc.constraint
    def cr5(self):
        vsc.solve_order(self.IsIspBypassMode, self.IsIspDstCompType)
        vsc.solve_order(self.IsIspSrcCompType, self.IsIspDstCompType)
        vsc.solve_order(self.IsIspYuvFormat, self.IsIspSrcCompType)
        vsc.solve_order(self.IsIspDstCompType, self.IsIspInBittageType)
        vsc.solve_order(self.IsIspInBittageType, self.IsIspOutBittageType)
        with vsc.if_then((self.IsIspBypassMode != 0)):
            self.IsIspDstCompType == self.IsIspSrcCompType

    @vsc.constraint
    def cr6(self):
        vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsIspInBittageType)
        vsc.solve_order(self.IsIspYuvFormat, self.IsIspSrcCompType)
        vsc.solve_order(self.IsIspSrcCompType, self.IsIspDstCompType)
        vsc.solve_order(self.IsIspDstCompType, self.IsIspInBittageType)
        vsc.solve_order(self.IsIspInBittageType, self.IsIspOutBittageType)
        with vsc.if_then(self.IsRdmaDataFormatYuv.inside(vsc.rangelist(4, 5, 7, 8))):
            self.IsIspInBittageType == 0
        with vsc.else_if(self.IsRdmaDataFormatYuv.inside(vsc.rangelist(16, 17, 32, 33))):
            self.IsIspInBittageType == 1
        with vsc.else_then:
            self.IsIspInBittageType == 3

    @vsc.constraint
    def cr7(self):
        vsc.solve_order(self.IsIspInBittageType, self.IsIspOutBittageType)
        vsc.solve_order(self.IsIspDstCompType, self.IsIspOutBittageType)
        vsc.solve_order(self.IsIspYuvFormat, self.IsIspSrcCompType)
        vsc.solve_order(self.IsIspSrcCompType, self.IsIspDstCompType)
        vsc.solve_order(self.IsIspDstCompType, self.IsIspInBittageType)
        vsc.solve_order(self.IsIspInBittageType, self.IsIspOutBittageType)
        with vsc.if_then(self.IsIspInBittageType == 0):
            self.IsIspOutBittageType == 0
        with vsc.else_if(self.IsIspDstCompType > 0):
            self.IsIspOutBittageType == 1
        with vsc.else_then:
            self.IsIspOutBittageType.inside(vsc.rangelist(1, 3))

    @vsc.constraint
    def cr8_solve_order_test(self):
        vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsWdmaDataFormatYuv)
        vsc.solve_order(self.IsIspBypassMode, self.IsIspYuvFormat)
        vsc.solve_order(self.IsIspYuvFormat, self.IsIspSrcCompType)
        vsc.solve_order(self.IsIspSrcCompType, self.IsIspDstCompType)
        vsc.solve_order(self.IsIspDstCompType, self.IsIspInBittageType)
        vsc.solve_order(self.IsIspInBittageType, self.IsIspOutBittageType)
        with vsc.if_then((self.IsIspBypassMode != 0)):
            self.IsIspYuvFormat == 0
        with vsc.else_then:
            self.IsIspYuvFormat == 1

    @vsc.constraint
    def CR_SIGNED_RANGE_isp_grid_2d(self):
        self.isp_grid_2d_0_0 in vsc.rangelist(vsc.rng(-1024, 1023))
        self.isp_grid_2d_0_1 in vsc.rangelist(vsc.rng(-1024, 1023))
        self.isp_grid_2d_0_2 in vsc.rangelist(vsc.rng(-512, 511))
        self.isp_grid_2d_0_3 in vsc.rangelist(vsc.rng(-512, 511))
        self.isp_grid_2d_0_4.inside(vsc.rangelist(-100, -50, 0, 50, 100))
        self.isp_grid_2d_0_6 in vsc.rangelist(vsc.rng(-2048, 2047))

    @vsc.constraint
    def cr9_single_logical_ops(self):
        (self.IsIspBypassMode == 1) & (self.IsIspYuvFormat == 0)
        (self.IsIspSrcCompType == 0) | (self.IsIspDstCompType == 1)
        (self.IsIspInBittageType >= 0) & (self.IsIspInBittageType <= 2) | (self.IsIspOutBittageType == 3)

    @vsc.constraint
    def cr10_bit_slice(self):
        self.IsIspBypassMode[3:0] == 0

    @vsc.constraint
    def cr11_bit_slice(self):
        self.IsIspYuvFormat[7:4] == 0

    @vsc.constraint
    def cr12_bit_slice(self):
        self.IsIspSrcCompType[15:0] == self.IsIspDstCompType[15:0]

    @vsc.constraint
    def cr13_paren_range(self):
        self.isp_grid_2d_0_0 in vsc.rangelist(vsc.rng(-8388607, 8388607))

    @vsc.constraint
    def cr14_paren_range(self):
        self.isp_grid_2d_0_1 in vsc.rangelist(vsc.rng(-8388607, 8388607))

# =============================================================================
# USAGE EXAMPLE
# =============================================================================

if __name__ == '__main__':
    # Set seed for reproducibility (optional)
    # vsc.set_randstate(12345)

    # Create and randomize IspRandItemSmall
    isp_rand_item_small = IspRandItemSmall()
    isp_rand_item_small.randomize()
    print(f'IspRandItemSmall randomized successfully')

    # Print field values
    print(f'  TestRandInt = {isp_rand_item_small.TestRandInt}')
    print(f'  TestRandNibble = {isp_rand_item_small.TestRandNibble}')
    print(f'  TestEnum = {isp_rand_item_small.TestEnum}')
    print(f'  TestFixedArr = {isp_rand_item_small.TestFixedArr}')
    print(f'  TestDynArr = {isp_rand_item_small.TestDynArr}')
