#!/usr/bin/env python3
"""
Auto-generated pyvsc translation from SystemVerilog

IMPORTANT: This is a SUGGESTED translation that requires manual review.
Please verify:
1. All constraint semantics are preserved
2. Data type mappings are correct
3. Distribution weights match original intent
4. Solve order effects are equivalent

Generated by: SV-to-pyvsc Translation Assistant
"""

import vsc
from enum import IntEnum
import random
from typing import Optional

class YuvFormat(IntEnum):
  """Translated from SV enum: yuv_format_e"""
  YUV_444 = 0
  YUV_422 = 1
  YUV_420 = 2

class YuvPacking(IntEnum):
  """Translated from SV enum: yuv_packing_e"""
  YUV_PLANAR = 0
  YUV_SEMI_PLANAR = 1
  YUV_PACKED = 2

class ColorSpace(IntEnum):
  """Translated from SV enum: color_space_e"""
  CS_BT601 = 0
  CS_BT709 = 1
  CS_BT2020 = 2

class BitDepth(IntEnum):
  """Translated from SV enum: bit_depth_e"""
  BIT_8 = 8
  BIT_10 = 10
  BIT_12 = 12

class RgbFormat(IntEnum):
  """Translated from SV enum: rgb_format_e"""
  RGB_888 = 0
  RGB_101010 = 1
  RGB_121212 = 2

class RangeMode(IntEnum):
  """Translated from SV enum: range_mode_e"""
  FULL_RANGE = 0
  LIMITED_RANGE = 1

@vsc.randobj
class IspYuv2rgbCfg:
  """Translated from SV class: isp_yuv2rgb_cfg"""

  def __init__(self):
    self.enable = vsc.rand_bit_t(1)
    self.yuv_format = vsc.rand_int32_t()
    self.yuv_packing = vsc.rand_int32_t()
    self.yuv_bit_depth = vsc.rand_int32_t()
    self.color_space = vsc.rand_int32_t()
    self.range_mode = vsc.rand_int32_t()
    self.rgb_format = vsc.rand_int32_t()
    self.width = vsc.rand_uint32_t()
    self.height = vsc.rand_uint32_t()
    self.chroma_enabled = vsc.rand_bit_t(1)
    self.dither_enable = vsc.rand_bit_t(1)
    self.clip_enable = vsc.rand_bit_t(1)
    self.c00 = vsc.rand_int32_t()
    self.c01 = vsc.rand_int32_t()
    self.c02 = vsc.rand_int32_t()
    self.c10 = vsc.rand_int32_t()
    self.c11 = vsc.rand_int32_t()
    self.c12 = vsc.rand_int32_t()
    self.c20 = vsc.rand_int32_t()
    self.c21 = vsc.rand_int32_t()
    self.c22 = vsc.rand_int32_t()
    self.y_offset = vsc.rand_int32_t()
    self.uv_offset = vsc.rand_int32_t()
    self.a = vsc.rand_int32_t()
    self.b = vsc.rand_int32_t()
    self.c = vsc.rand_int32_t()
    self.d = vsc.rand_int32_t()
    self.x = vsc.rand_int32_t()
    self.y = vsc.rand_int32_t()
    self.z = vsc.rand_int32_t()
    self.w = vsc.rand_int32_t()
    self.arith_width = vsc.rand_int32_t()
    self.stride = vsc.rand_int32_t()
    self.fmt = vsc.rand_int32_t()
    self.bit_depth = vsc.rand_int32_t()
    self.arith_y_offset = vsc.rand_int32_t()
    self.signed_val = vsc.rand_int32_t()
    self.unsigned_val = vsc.rand_uint32_t()
    self.mode = vsc.rand_int32_t()
    self.range = vsc.rand_int32_t()
    self.IsRdmaDataFormatYuv = vsc.rand_int32_t()
    self.IsYuvFormat = vsc.rand_int32_t()
    self.IsInBittageType = vsc.rand_int32_t()

  @vsc.constraint
  def cr_default_rangelists(self):
    self.yuv_format in vsc.rangelist(YuvFormat.YUV_444, YuvFormat.YUV_422, YuvFormat.YUV_420)
    self.yuv_packing in vsc.rangelist(YuvPacking.YUV_PLANAR, YuvPacking.YUV_SEMI_PLANAR, YuvPacking.YUV_PACKED)
    self.color_space in vsc.rangelist(ColorSpace.CS_BT601, ColorSpace.CS_BT709, ColorSpace.CS_BT2020)
    self.range_mode in vsc.rangelist(RangeMode.FULL_RANGE, RangeMode.LIMITED_RANGE)
    self.rgb_format in vsc.rangelist(RgbFormat.RGB_888, RgbFormat.RGB_101010, RgbFormat.RGB_121212)
    self.yuv_bit_depth in vsc.rangelist(BitDepth.BIT_8, BitDepth.BIT_10, BitDepth.BIT_12)
    self.enable in vsc.rangelist(0, 1)
    self.chroma_enabled in vsc.rangelist(0, 1)
    self.dither_enable in vsc.rangelist(0, 1)
    self.clip_enable in vsc.rangelist(0, 1)
    self.width in vsc.rangelist(vsc.rng(64, 16384))
    self.height in vsc.rangelist(vsc.rng(64, 16384))
    self.c00 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c01 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c02 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c10 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c11 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c12 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c20 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c21 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c22 in vsc.rangelist(vsc.rng(-1024, 1023))
    self.y_offset in vsc.rangelist(vsc.rng(-65536, 65535))
    self.uv_offset in vsc.rangelist(vsc.rng(-65536, 65535))
    self.arith_y_offset in vsc.rangelist(vsc.rng(-65536, 65535))
    self.a in vsc.rangelist(vsc.rng(-1024, 1023))
    self.b in vsc.rangelist(vsc.rng(-1024, 1023))
    self.c in vsc.rangelist(vsc.rng(-1024, 1023))
    self.d in vsc.rangelist(vsc.rng(1, 1024))
    self.x in vsc.rangelist(vsc.rng(-4096, 4095))
    self.y in vsc.rangelist(vsc.rng(-4096, 4095))
    self.z in vsc.rangelist(vsc.rng(-4096, 4095))
    self.w in vsc.rangelist(vsc.rng(-4096, 4095))
    self.arith_width in vsc.rangelist(vsc.rng(1, 16384))
    self.stride in vsc.rangelist(vsc.rng(1, 131072))
    self.bit_depth in vsc.rangelist(vsc.rng(1, 16))
    self.fmt in vsc.rangelist(vsc.rng(0, 3))
    self.mode in vsc.rangelist(vsc.rng(0, 3))
    self.range in vsc.rangelist(vsc.rng(0, 1))
    self.signed_val in vsc.rangelist(vsc.rng(-128, 127))
    self.unsigned_val in vsc.rangelist(vsc.rng(0, 255))

  @vsc.constraint
  def cr_basic_ranges(self):
    self.enable in vsc.rangelist(0, 1)
    self.width in vsc.rangelist(vsc.rng(64, 8192))
    self.height in vsc.rangelist(vsc.rng(64, 8192))

  @vsc.constraint
  def cr_format_packing(self):
    with vsc.if_then(self.yuv_packing == YuvPacking.YUV_PACKED):
      self.yuv_format != YuvFormat.YUV_420
    with vsc.if_then(self.yuv_format == YuvFormat.YUV_420):
      self.yuv_packing != YuvPacking.YUV_PACKED

  @vsc.constraint
  def cr_bit_depth(self):
    with vsc.if_then(self.yuv_packing == YuvPacking.YUV_PACKED):
      self.yuv_bit_depth in vsc.rangelist(BitDepth.BIT_8, BitDepth.BIT_10)
    with vsc.if_then(self.rgb_format == RgbFormat.RGB_888):
      self.yuv_bit_depth == BitDepth.BIT_8
    with vsc.else_if(self.rgb_format == RgbFormat.RGB_101010):
      self.yuv_bit_depth in vsc.rangelist(BitDepth.BIT_10, BitDepth.BIT_12)
    with vsc.else_then:
      self.yuv_bit_depth == BitDepth.BIT_12

  @vsc.constraint
  def cr_chroma(self):
    with vsc.if_then(self.yuv_format == YuvFormat.YUV_444):
      self.chroma_enabled == 1
    with vsc.else_then:
      self.chroma_enabled in vsc.rangelist(0, 1)

  @vsc.constraint
  def cr_color_matrix(self):
    vsc.solve_order(self.color_space, self.c00)
    vsc.solve_order(self.color_space, self.c01)
    vsc.solve_order(self.color_space, self.c02)
    vsc.solve_order(self.color_space, self.c10)
    vsc.solve_order(self.color_space, self.c11)
    vsc.solve_order(self.color_space, self.c12)
    vsc.solve_order(self.color_space, self.c20)
    vsc.solve_order(self.color_space, self.c21)
    vsc.solve_order(self.color_space, self.c22)
    with vsc.if_then(self.color_space == ColorSpace.CS_BT601):
      self.c00==298
      self.c01==0
      self.c02==409
      self.c10==298
      self.c11==-100
      self.c12==-208
      self.c20==298
      self.c21==516
      self.c22==0
    with vsc.else_if(self.color_space == ColorSpace.CS_BT709):
      self.c00==298
      self.c01==0
      self.c02==459
      self.c10==298
      self.c11==-55
      self.c12==-136
      self.c20==298
      self.c21==541
      self.c22==0
    with vsc.else_then:
      self.c00==298
      self.c01==0
      self.c02==483
      self.c10==298
      self.c11==-57
      self.c12==-157
      self.c20==298
      self.c21==565
      self.c22==0

  @vsc.constraint
  def cr_offsets(self):
    vsc.solve_order(self.range_mode, self.y_offset)
    vsc.solve_order(self.range_mode, self.uv_offset)
    vsc.solve_order(self.yuv_bit_depth, self.y_offset)
    vsc.solve_order(self.yuv_bit_depth, self.uv_offset)
    with vsc.if_then(self.range_mode == RangeMode.FULL_RANGE):
      self.y_offset  == 0
      self.uv_offset == (vsc.unsigned(1) << (self.yuv_bit_depth-1))
    with vsc.else_then:
      self.y_offset  == (vsc.unsigned(16) << (self.yuv_bit_depth-8))
      self.uv_offset == (vsc.unsigned(128) << (self.yuv_bit_depth-8))

  @vsc.constraint
  def cr_dither_clip(self):
    vsc.solve_order(self.yuv_bit_depth, self.dither_enable)
    vsc.solve_order(self.rgb_format, self.dither_enable)
    vsc.solve_order(self.range_mode, self.clip_enable)
    with vsc.if_then((self.yuv_bit_depth > BitDepth.BIT_8)  &  (self.rgb_format == RgbFormat.RGB_888)):
      self.dither_enable == 1
    with vsc.else_then:
      self.dither_enable in vsc.rangelist(0, 1)
    with vsc.if_then(self.range_mode == RangeMode.LIMITED_RANGE):
      self.clip_enable == 1

  @vsc.constraint
  def cr_dimension_alignment(self):
    vsc.solve_order(self.yuv_format, self.width)
    vsc.solve_order(self.yuv_format, self.height)
    with vsc.if_then(self.yuv_format == YuvFormat.YUV_420):
      (self.width  % 2) == 0
      (self.height % 2) == 0
    with vsc.else_if(self.yuv_format == YuvFormat.YUV_422):
      (self.width % 2) == 0

  @vsc.constraint
  def cr_distributions(self):
    vsc.dist(self.yuv_format, [
      vsc.weight(YuvFormat.YUV_444, 20),
      vsc.weight(YuvFormat.YUV_422, 50),
      vsc.weight(YuvFormat.YUV_420, 30),
    ])
    vsc.dist(self.yuv_bit_depth, [
      vsc.weight(BitDepth.BIT_8, 60),
      vsc.weight(BitDepth.BIT_10, 30),
      vsc.weight(BitDepth.BIT_12, 10),
    ])
    vsc.dist(self.color_space, [
      vsc.weight(ColorSpace.CS_BT601, 40),
      vsc.weight(ColorSpace.CS_BT709, 40),
      vsc.weight(ColorSpace.CS_BT2020, 20),
    ])

  @vsc.constraint
  def tc_logical_ops(self):
    with vsc.if_then((self.a > 8)  &  (self.b < 4)):
      self.c == 1
    with vsc.else_then:
      self.c == 0

  @vsc.constraint
  def tc_int_div(self):
    self.stride == (self.arith_width * 10 + 7) // 8

  @vsc.constraint
  def tc_signed_unsigned(self):
    self.signed_val in vsc.rangelist(vsc.rng(-128, 127))
    self.unsigned_val == self.signed_val + 128

  @vsc.constraint
  def tc_parallel_if(self):
    with vsc.if_then(self.a == 0):
      self.b == 1
    with vsc.if_then(self.c == 0):
      self.d == 2

  @vsc.constraint
  def tc_not(self):
    with vsc.if_then((self.mode != 0)):
      self.bit_depth == BitDepth.BIT_10

  @vsc.constraint
  def tc_shift(self):
    self.arith_y_offset == (vsc.unsigned(1) << (self.bit_depth - 1))
    self.x == self.y << 2
    self.z == self.w >> 1

  @vsc.constraint
  def tc_modulo(self):
    (self.x % 2) == 0
    (self.arith_width % 4) == 0

  @vsc.constraint
  def tc_conditional_stride(self):
    with vsc.if_then(self.fmt == 0):
      self.stride >= (self.arith_width * 8 + 7) // 8

  @vsc.constraint
  def tc_golden(self):
    with vsc.if_then(self.fmt == 0):
      self.stride >= (self.arith_width * self.bit_depth + 7) // 8
      self.stride <= ((self.arith_width * self.bit_depth + 7) // 8) * 125 // 100

  @vsc.constraint
  def cr_inside_if(self):
    vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsYuvFormat)
    with vsc.if_then(self.IsRdmaDataFormatYuv.inside(vsc.rangelist(4, 5, 16, 17, 20, 21))):
      self.IsYuvFormat == 0
    with vsc.else_then:
      self.IsYuvFormat == 1

  @vsc.constraint
  def cr_inside_else_if(self):
    vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsInBittageType)
    with vsc.if_then(self.IsRdmaDataFormatYuv.inside(vsc.rangelist(4, 5, 7, 8))):
      self.IsInBittageType == 0
    with vsc.else_if(self.IsRdmaDataFormatYuv.inside(vsc.rangelist(16, 17, 32, 33))):
      self.IsInBittageType == 1
    with vsc.else_then:
      self.IsInBittageType == 3

  @vsc.constraint
  def cr_inside_standalone(self):
    self.IsRdmaDataFormatYuv in vsc.rangelist(4, 5, 7, 8, 16, 17, 20, 21, 32, 33)

  @vsc.constraint
  def cr_inside_implies(self):
    with vsc.implies((self.mode == 1)):
      self.IsRdmaDataFormatYuv in vsc.rangelist(4, 5, 16, 17)

  @vsc.constraint
  def cr_complex_logic(self):
    with vsc.if_then((self.a > 0)  &  (self.b < 10)  |  (self.c == 5)):
      self.d == 1
    with vsc.else_then:
      self.d == 2

  @vsc.constraint
  def cr_negation(self):
    with vsc.if_then((self.a != 0)  &  (self.b != 0)):
      self.c == self.a + self.b

  @vsc.constraint
  def cr_implication_inside_antecedent(self):
    with vsc.implies((self.IsRdmaDataFormatYuv.inside(vsc.rangelist(4, 5)))):
      (self.IsYuvFormat == 0)

# =============================================================================
# USAGE EXAMPLE
# =============================================================================

if __name__ == '__main__':
  # Set seed for reproducibility (optional)
  # vsc.set_randstate(12345)

  # Create and randomize IspYuv2rgbCfg
  isp_yuv2rgb_cfg = IspYuv2rgbCfg()
  isp_yuv2rgb_cfg_randomized = False
  try:
    isp_yuv2rgb_cfg.randomize()
    isp_yuv2rgb_cfg_randomized = True
    print(f'IspYuv2rgbCfg randomized successfully')
  except Exception as e:
    print(f'IspYuv2rgbCfg randomize failed: {e}')

  if isp_yuv2rgb_cfg_randomized:
    # Print field values
    print(f'  enable = {isp_yuv2rgb_cfg.enable}')
    print(f'  yuv_format = {isp_yuv2rgb_cfg.yuv_format}')
    print(f'  yuv_packing = {isp_yuv2rgb_cfg.yuv_packing}')
    print(f'  yuv_bit_depth = {isp_yuv2rgb_cfg.yuv_bit_depth}')
    print(f'  color_space = {isp_yuv2rgb_cfg.color_space}')
