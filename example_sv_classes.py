#!/usr/bin/env python3
"""
Auto-generated pyvsc translation from SystemVerilog

IMPORTANT: This is a SUGGESTED translation that requires manual review.
Please verify:
1. All constraint semantics are preserved
2. Data type mappings are correct
3. Distribution weights match original intent
4. Solve order effects are equivalent

Generated by: SV-to-pyvsc Translation Assistant
"""

import vsc
from enum import IntEnum
import random
from typing import Optional

# =============================================================================
# BASE CLASS STUBS (from UVM or other libraries)
# Replace these with actual implementations or imports as needed
# =============================================================================

@vsc.randobj
class UvmSequenceItem:
    """
    Stub for uvm_sequence_item base class.
    Replace with actual implementation or import from your UVM library.
    """
    def __init__(self):
        pass  # TODO: Add base class fields if needed


@vsc.randobj
class IspRandItemSmall(UvmSequenceItem):
    """Translated from SV class: Isp_rand_item_small"""

    def __init__(self):
        super().__init__()
        self.IsIspBypassMode = vsc.rand_bit_t(32)
        self.IsIspYuvFormat = vsc.rand_bit_t(32)
        self.IsIspSrcCompType = vsc.rand_bit_t(32)
        self.IsIspDstCompType = vsc.rand_bit_t(32)
        self.IsIspInBittageType = vsc.rand_bit_t(32)
        self.IsIspOutBittageType = vsc.rand_bit_t(32)
        self.IsRdmaDataFormatYuv = vsc.rand_bit_t(32)
        self.IsWdmaDataFormatYuv = vsc.rand_bit_t(32)
        self.isp_grid_2d_0_0 = vsc.rand_int32_t()
        self.isp_grid_2d_0_1 = vsc.rand_int32_t()
        self.isp_grid_2d_0_2 = vsc.rand_int32_t()
        self.isp_grid_2d_0_3 = vsc.rand_int32_t()
        self.isp_grid_2d_0_4 = vsc.rand_int32_t()
        self.isp_grid_2d_0_6 = vsc.rand_int32_t()

    @vsc.constraint
    def CR_VAR_RANGE_IsIspBypassMode(self):
        self.IsIspBypassMode >= 0 and self.IsIspBypassMode <= 1

    @vsc.constraint
    def CR_VAR_RANGE_IsIspYuvFormat(self):
        self.IsIspYuvFormat >= 0 and self.IsIspYuvFormat <= 1

    @vsc.constraint
    def CR_VAR_RANGE_IsIspSrcCompType(self):
        self.IsIspSrcCompType >= 0 and self.IsIspSrcCompType <= 2

    @vsc.constraint
    def CR_VAR_RANGE_IsIspDstCompType(self):
        self.IsIspDstCompType >= 0 and self.IsIspDstCompType <= 2

    @vsc.constraint
    def CR_VAR_RANGE_IsIspInBittageType(self):
        self.IsIspInBittageType >= 0 and self.IsIspInBittageType <= 3

    @vsc.constraint
    def CR_VAR_RANGE_IsIspOutBittageType(self):
        self.IsIspOutBittageType >= 0 and self.IsIspOutBittageType <= 3

    @vsc.constraint
    def cr1(self):
        with vsc.if_then(self.IsRdmaDataFormatYuv in vsc.rangelist(4, 5, 16, 17, 20, 21)):
            self.IsIspYuvFormat == 0
        with vsc.else_then:
            self.IsIspYuvFormat == 1
        vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsIspYuvFormat)

    @vsc.constraint
    def cr4(self):
        with vsc.if_then((self.IsIspBypassMode != 0)):
            self.IsIspSrcCompType in vsc.rangelist(0, 1)
        vsc.solve_order(self.IsIspBypassMode, self.IsIspSrcCompType)

    @vsc.constraint
    def cr5(self):
        with vsc.if_then((self.IsIspBypassMode != 0)):
            self.IsIspDstCompType == self.IsIspSrcCompType
        vsc.solve_order(self.IsIspBypassMode, self.IsIspDstCompType)
        vsc.solve_order(self.IsIspSrcCompType, self.IsIspDstCompType)

    @vsc.constraint
    def cr6(self):
        with vsc.if_then(self.IsRdmaDataFormatYuv in vsc.rangelist(4, 5, 7, 8)):
            self.IsIspInBittageType == 0
        with vsc.else_if(self.IsRdmaDataFormatYuv in vsc.rangelist(16, 17, 32, 33)):
            self.IsIspInBittageType == 1
        with vsc.else_then:
            self.IsIspInBittageType == 3
        vsc.solve_order(self.IsRdmaDataFormatYuv, self.IsIspInBittageType)

    @vsc.constraint
    def cr7(self):
        with vsc.if_then(self.IsIspInBittageType == 0):
            self.IsIspOutBittageType == 0
        with vsc.else_if(self.IsIspDstCompType > 0):
            self.IsIspOutBittageType == 1
        with vsc.else_then:
            self.IsIspOutBittageType in vsc.rangelist(1, 3)
        vsc.solve_order(self.IsIspInBittageType, self.IsIspOutBittageType)
        vsc.solve_order(self.IsIspDstCompType, self.IsIspOutBittageType)

    @vsc.constraint
    def CR_SIGNED_RANGE_isp_grid_2d(self):
        self.isp_grid_2d_0_0 >= -1024 and self.isp_grid_2d_0_0 <= 1023
        self.isp_grid_2d_0_1 >= -1024 and self.isp_grid_2d_0_1 <= 1023
        self.isp_grid_2d_0_2 >= -512 and self.isp_grid_2d_0_2 <= 511
        self.isp_grid_2d_0_3 >= -512 and self.isp_grid_2d_0_3 <= 511
        self.isp_grid_2d_0_4 in vsc.rangelist(-100, -50, 0, 50, 100)
        self.isp_grid_2d_0_6 >= -2048 and self.isp_grid_2d_0_6 <= 2047

# =============================================================================
# USAGE EXAMPLE
# =============================================================================

if __name__ == '__main__':
    # Set seed for reproducibility (optional)
    # vsc.set_randstate(12345)

    # Create and randomize IspRandItemSmall
    isp_rand_item_small = IspRandItemSmall()
    isp_rand_item_small.randomize()
    print(f'IspRandItemSmall randomized successfully')

    # Print field values
    print(f'  IsIspBypassMode = {isp_rand_item_small.IsIspBypassMode}')
    print(f'  IsIspYuvFormat = {isp_rand_item_small.IsIspYuvFormat}')
    print(f'  IsIspSrcCompType = {isp_rand_item_small.IsIspSrcCompType}')
    print(f'  IsIspDstCompType = {isp_rand_item_small.IsIspDstCompType}')
    print(f'  IsIspInBittageType = {isp_rand_item_small.IsIspInBittageType}')
