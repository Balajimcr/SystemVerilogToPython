#!/usr/bin/env python3
"""
Auto-generated pyvsc translation from SystemVerilog

IMPORTANT: This is a SUGGESTED translation that requires manual review.
Please verify:
1. All constraint semantics are preserved
2. Data type mappings are correct
3. Distribution weights match original intent
4. Solve order effects are equivalent

Generated by: SV-to-pyvsc Translation Assistant
"""


import vsc
from enum import IntEnum
import random
from typing import Optional

class BurstType(IntEnum):
    """Translated from SV enum: burst_type_e"""
    FIXED = 0
    INCR = 1
    WRAP = 2

class CmdType(IntEnum):
    """Translated from SV enum: cmd_type_e"""
    READ = 0
    WRITE = 1
    IDLE = 2

class PktType(IntEnum):
    """Translated from SV enum: pkt_type_e"""
    PKT_DATA = 0
    PKT_ACK = 1
    PKT_NACK = 2
    PKT_CTRL = 3
    PKT_STATUS = 4

@vsc.randobj
class BasicTransaction:
    """
    Translated from SV class: basic_transaction
    """

    def __init__(self):
        self.addr = vsc.rand_bit_t(8)  # rand bit [7:0]  addr;
        self.data = vsc.rand_bit_t(32)  # rand bit [31:0] data;
        self.burst_len = vsc.rand_bit_t(4)  # rand bit [3:0]  burst_len;
        self.fixed_mode = vsc.bit_t(2)  # bit [1:0]  fixed_mode;
        self.cyclic_val = vsc.randc_bit_t(4)  # randc bit [3:0] cyclic_val;

    @vsc.constraint
    def addr_range_c(self):
        """
        Original SV constraint:
        addr inside {[8'h10:8'hF0]};
        """
        self.addr in vsc.rangelist(vsc.rng(0x10, 0xF0))

    @vsc.constraint
    def data_c(self):
        """
        Original SV constraint:
        addr < 8'h20 -> data == 32'h0;
        """
        vsc.implies(self.addr < 0x20, self.data == 0x0)

    @vsc.constraint
    def burst_c(self):
        """
        Original SV constraint:
        burst_len inside {[1:8]};
        """
        self.burst_len in vsc.rangelist(vsc.rng(1, 8))

@vsc.randobj
class AxiTransaction:
    """
    Translated from SV class: axi_transaction
    """

    def __init__(self):
        self.addr = vsc.rand_bit_t(32)  # rand bit [31:0]     addr;
        self.data = vsc.rand_list_t(vsc.bit_t(8))  # rand bit [7:0]      data[];
        self.size = vsc.rand_bit_t(3)  # rand bit [2:0]      size;
        self.len = vsc.rand_bit_t(8)  # rand bit [7:0]      len;
        self.write = vsc.rand_bit_t(1)  # rand bit            write;

    @vsc.constraint
    def valid_size_c(self):
        """
        Original SV constraint:
        size inside {[0:3]};
        """
        self.size in vsc.rangelist(vsc.rng(0, 3))

    @vsc.constraint
    def data_size_c(self):
        """
        Original SV constraint:
        data.size() == (len + 1);
        """
        self.data.size == (self.len + 1)

    @vsc.constraint
    def addr_align_c(self):
        """
        Original SV constraint:
        (addr % (1 << size)) == 0;
        """
        (self.addr % (1 << self.size)) == 0

    @vsc.constraint
    def wrap_c(self):
        """
        Original SV constraint:
        (burst == WRAP) -> (len inside {1, 3, 7, 15});
        """
        vsc.implies((self.burst == self.WRAP), self.len in vsc.rangelist(1, 3, 7, 15))

    @vsc.constraint
    def len_dist_c(self):
        """
        Original SV constraint:
        len inside {[0:15]};
        len dist {
        [0:3]   := 60,
        [4:7]   := 25,
        [8:15]  := 15
        };
        """
        self.len in vsc.rangelist(vsc.rng(0, 15))
        vsc.dist(self.len, [
            vsc.weight(vsc.rng(0, 3), 60),
            vsc.weight(vsc.rng(4, 7), 25),
            vsc.weight(vsc.rng(8, 15), 15),
        ])

    @vsc.constraint
    def burst_dist_c(self):
        """
        Original SV constraint:
        burst dist {
        INCR  := 70,
        FIXED := 20,
        WRAP  := 10
        };
        """
        vsc.dist(self.burst, [
            vsc.weight(INCR, 70),
            vsc.weight(FIXED, 20),
            vsc.weight(WRAP, 10),
        ])

    @vsc.constraint
    def solve_order_c(self):
        """
        Original SV constraint:
        solve burst before len;
        solve len before data;
        """
        vsc.solve_order(self.burst, self.len)
        vsc.solve_order(self.len, self.data)

@vsc.randobj
class ProtocolPacket:
    """
    Translated from SV class: protocol_packet
    """

    def __init__(self):
        self.seq_num = vsc.rand_bit_t(16)  # rand bit [15:0]   seq_num;
        self.payload = vsc.rand_list_t(vsc.bit_t(8))  # rand bit [7:0]    payload[];
        self.src_id = vsc.rand_bit_t(8)  # rand bit [7:0]    src_id;
        self.dst_id = vsc.rand_bit_t(8)  # rand bit [7:0]    dst_id;
        self.priority = vsc.rand_bit_t(1)  # rand bit          priority;
        self.flags = vsc.rand_bit_t(16)  # rand bit [15:0]   flags;

    @vsc.constraint
    def solve_order_c(self):
        """
        Original SV constraint:
        solve pkt_type before payload;
        solve pkt_type before flags;
        """
        vsc.solve_order(self.pkt_type, self.payload)
        vsc.solve_order(self.pkt_type, self.flags)

    @vsc.constraint
    def payload_size_c(self):
        """
        Original SV constraint:
        if (pkt_type == PKT_DATA) {
        payload.size() inside {[64:256]};
        } else if (pkt_type == PKT_CTRL) {
        payload.size() inside {[8:64]};
        } else {
        payload.size() == 0;
        }
        """
        with vsc.if_then(self.pkt_type == self.PKT_DATA):
            self.payload.size() self.inside {[64:256]
        with vsc.else_if(self.pkt_type == self.PKT_CTRL):
            self.payload.size() self.inside {[8:64]
        with vsc.else_then:
            self.payload.size == 0

    @vsc.constraint
    def flags_c(self):
        """
        Original SV constraint:
        if (pkt_type == PKT_ACK || pkt_type == PKT_NACK) {
        flags[0] == 1;
        } else {
        flags[0] == 0;
        }
        priority -> flags[1];
        """
        with vsc.if_then(self.pkt_type == self.PKT_ACK || self.pkt_type == self.PKT_NACK):
            self.flags[0] == 1

    @vsc.constraint
    def id_c(self):
        """
        Original SV constraint:
        src_id != dst_id;
        src_id inside {[1:254]};
        dst_id inside {[1:254]};
        """
        self.src_id != self.dst_id
        self.src_id in vsc.rangelist(vsc.rng(1, 254))
        self.dst_id in vsc.rangelist(vsc.rng(1, 254))

    @vsc.constraint
    def type_dist_c(self):
        """
        Original SV constraint:
        pkt_type dist {
        PKT_DATA   := 50,
        PKT_ACK    := 20,
        PKT_NACK   := 5,
        PKT_CTRL   := 15,
        PKT_STATUS := 10
        };
        """
        vsc.dist(self.pkt_type, [
            vsc.weight(PKT_DATA, 50),
            vsc.weight(PKT_ACK, 20),
            vsc.weight(PKT_NACK, 5),
            vsc.weight(PKT_CTRL, 15),
            vsc.weight(PKT_STATUS, 10),
        ])

@vsc.randobj
class ArrayExample:
    """
    Translated from SV class: array_example
    """

    def __init__(self):
        self.data_arr = vsc.rand_list_t(vsc.bit_t(8), sz=16)  # rand bit [7:0] data_arr[16];
        self.index_arr = vsc.rand_list_t(vsc.bit_t(4), sz=8)  # rand bit [3:0] index_arr[8];

    @vsc.constraint
    def arr_size_c(self):
        """
        Original SV constraint:
        values.size() inside {[4:16]};
        """
        self.values.size in vsc.rangelist(vsc.rng(4, 16))

    @vsc.constraint
    def foreach_c(self):
        """
        Original SV constraint:
        foreach (data_arr[i]) {
        data_arr[i] > i;
        data_arr[i] < 200;
        }
        """
        with vsc.foreach(self.data_arr, idx=True) as i:
            self.data_arr[self.i] > self.i
            self.data_arr[self.i] < 200

    @vsc.constraint
    def ascending_c(self):
        """
        Original SV constraint:
        foreach (data_arr[i]) {
        if (i > 0) {
        data_arr[i] > data_arr[i-1];
        }
        }
        """
        with vsc.foreach(self.data_arr, idx=True) as i:
            with vsc.if_then(self.i > 0):
                self.data_arr[self.i] > self.data_arr[self.i-1]

    @vsc.constraint
    def unique_c(self):
        """
        Original SV constraint:
        unique {index_arr};
        """
        vsc.unique(self.index_arr)

    @vsc.constraint
    def index_range_c(self):
        """
        Original SV constraint:
        foreach (index_arr[i]) {
        index_arr[i] inside {[0:15]};
        }
        """
        with vsc.foreach(self.index_arr, idx=True) as i:
            self.index_arr[self.i] self.inside {[0:15]}

@vsc.randobj
class BaseTransaction:
    """
    Translated from SV class: base_transaction
    """

    def __init__(self):
        self.addr = vsc.rand_bit_t(8)  # rand bit [7:0]  addr;
        self.data = vsc.rand_bit_t(32)  # rand bit [31:0] data;

    @vsc.constraint
    def base_addr_c(self):
        """
        Original SV constraint:
        addr inside {[0:127]};
        """
        self.addr in vsc.rangelist(vsc.rng(0, 127))

@vsc.randobj
class ExtendedTransaction(BaseTransaction):
    """
    Translated from SV class: extended_transaction
    """

    def __init__(self):
        super().__init__()
        self.burst_len = vsc.rand_bit_t(4)  # rand bit [3:0] burst_len;
        self.enable = vsc.rand_bit_t(1)  # rand bit       enable;

    @vsc.constraint
    def ext_addr_c(self):
        """
        Original SV constraint:
        addr inside {[64:127]};
        """
        self.addr in vsc.rangelist(vsc.rng(64, 127))

    @vsc.constraint
    def burst_c(self):
        """
        Original SV constraint:
        burst_len inside {[1:8]};
        (burst_len > 4) -> (addr[6:0] == 0);
        """
        self.burst_len in vsc.rangelist(vsc.rng(1, 8))
        vsc.implies((self.burst_len > 4), ((self.addr & 0x7F) == 0))

    @vsc.constraint
    def enable_c(self):
        """
        Original SV constraint:
        enable -> (data != 0);
        """
        vsc.implies(self.enable, (self.data != 0))

@vsc.randobj
class SoftExample:
    """
    Translated from SV class: soft_example
    """

    def __init__(self):
        self.addr = vsc.rand_bit_t(8)  # rand bit [7:0] addr;
        self.data = vsc.rand_bit_t(8)  # rand bit [7:0] data;
        self.mode = vsc.rand_bit_t(2)  # rand bit [1:0] mode;

    @vsc.constraint
    def hard_c(self):
        """
        Original SV constraint:
        addr inside {[0:255]};
        data inside {[0:255]};
        """
        self.addr in vsc.rangelist(vsc.rng(0, 255))
        self.data in vsc.rangelist(vsc.rng(0, 255))

    @vsc.constraint
    def soft_defaults_c(self):
        """
        Original SV constraint:
        soft addr == 8'h00;
        soft data == 8'hFF;
        soft mode == 2'b00;
        """
        vsc.soft(self.addr == 0x00)
        vsc.soft(self.data == 0xFF)
        vsc.soft(self.mode == 0b00)

# =============================================================================
# USAGE EXAMPLE
# =============================================================================

if __name__ == '__main__':
    # Set seed for reproducibility (optional)
    # vsc.set_randstate(12345)

    # Create and randomize BasicTransaction
    basic_transaction = BasicTransaction()
    basic_transaction.randomize()
    print(f'BasicTransaction randomized successfully')

    # Print field values
    print(f'  addr = {basic_transaction.addr}')
    print(f'  data = {basic_transaction.data}')
    print(f'  burst_len = {basic_transaction.burst_len}')
    print(f'  fixed_mode = {basic_transaction.fixed_mode}')
    print(f'  cyclic_val = {basic_transaction.cyclic_val}')

    # Create and randomize AxiTransaction
    axi_transaction = AxiTransaction()
    axi_transaction.randomize()
    print(f'AxiTransaction randomized successfully')

    # Print field values
    print(f'  addr = {axi_transaction.addr}')
    print(f'  data = {axi_transaction.data}')
    print(f'  size = {axi_transaction.size}')
    print(f'  len = {axi_transaction.len}')
    print(f'  write = {axi_transaction.write}')

    # Create and randomize ProtocolPacket
    protocol_packet = ProtocolPacket()
    protocol_packet.randomize()
    print(f'ProtocolPacket randomized successfully')

    # Print field values
    print(f'  seq_num = {protocol_packet.seq_num}')
    print(f'  payload = {protocol_packet.payload}')
    print(f'  src_id = {protocol_packet.src_id}')
    print(f'  dst_id = {protocol_packet.dst_id}')
    print(f'  priority = {protocol_packet.priority}')

    # Create and randomize ArrayExample
    array_example = ArrayExample()
    array_example.randomize()
    print(f'ArrayExample randomized successfully')

    # Print field values
    print(f'  data_arr = {array_example.data_arr}')
    print(f'  index_arr = {array_example.index_arr}')

    # Create and randomize BaseTransaction
    base_transaction = BaseTransaction()
    base_transaction.randomize()
    print(f'BaseTransaction randomized successfully')

    # Print field values
    print(f'  addr = {base_transaction.addr}')
    print(f'  data = {base_transaction.data}')

    # Create and randomize ExtendedTransaction
    extended_transaction = ExtendedTransaction()
    extended_transaction.randomize()
    print(f'ExtendedTransaction randomized successfully')

    # Print field values
    print(f'  burst_len = {extended_transaction.burst_len}')
    print(f'  enable = {extended_transaction.enable}')

    # Create and randomize SoftExample
    soft_example = SoftExample()
    soft_example.randomize()
    print(f'SoftExample randomized successfully')

    # Print field values
    print(f'  addr = {soft_example.addr}')
    print(f'  data = {soft_example.data}')
    print(f'  mode = {soft_example.mode}')
